> Understanding of chance could help us acquire wisdom. 
> ~ Richard McElreath


## 國王訪問個各島嶼問題

某個羣島國王的領土，恰好是圍成一圈的十個島嶼。每個島嶼的編號分別是 $1, 2, \dots, 10$。國王決定每個島嶼住幾周，且從長遠來說，每個島嶼居住的時間長度（週數），要和它的人口成正比。我們已知從 $1$ 號島嶼到 $10$ 號島嶼恰好是人口從少到多依次的順序。那麼該用怎樣的策略才能確保國王在每個島嶼呆的時間長短，和該島的人口成正比呢？

我們來聽聽看 Metropolis 的策略：

1. 無論該國王目前正在哪個島上，他每週都需要通過丟硬幣的方式決定是要再留一週，或者是離開該島移到左右兩邊的其中一個臨島去。
2. 如果硬幣是正面朝上，那麼國王會選擇順時針方向去往下一個臨島。如果是硬幣背面朝上，那麼國王會選擇逆時針方向去往下一個臨島。我們把這個通過投擲硬幣給出的提議稱作移島提案 (proposal island)。
3. 給出了移島提案之後，國王要根據所在島嶼的人口，選定符合準備要去的那個島嶼人口比例的貝殼個數。例如移島提案的島嶼人口排十個島嶼中第9，那麼國王從貝殼盒子裏取出9個貝殼。然後國王要從另一個裝滿了石子的盒子中取出和目前居住島嶼上人口比例相符的石頭。假如目前國王正在10號島嶼，那麼他需要取出10個石子。
4. 如果，第3步中取出的貝殼個數，比石子個數多，那麼國王就二話不說，根據移島提案去往下一個島（也就是會去往比目前島嶼人口多的那個島）。如果，貝殼個數比石子個數少的話，國王需要把等同於已有貝殼個數的石子拋棄。例如說是有4個貝殼（移島提案），和6個石子（目前的島嶼），那麼國王需要拋棄4個石子，保留2個石子和4個貝殼。然後國王把這2個石子和4個貝殼放在一個黑色的袋子裏，閉着眼睛從中抽取一個物體。如果抽到貝殼，那麼國王根據移島提案去4號島嶼，如果抽到的是石子，那麼國王選擇繼續留在目前的島嶼（6號）一週時間。也就是說，此時國王根據移島提案離開目前島嶼的概率是貝殼的數量除以未丟棄石子之前的數量，也就是提案島嶼的人口除以目前島嶼的人口。

這個 Metropolis 的策略看起來很荒誕，因爲似乎沒有半點邏輯，但是這個策略竟然是真實有效的。我們來進行一段計算機模擬以展示這個國王搬家的過程：

```{r introBayes12-01, cache=TRUE}
num_weeks <- 10000 # almost 2000 years time 
positions <- rep(0, num_weeks)
current <- 10
set.seed(1234)
for( i in 1:num_weeks ){
  ## record current position
  positions[i] <- current
  ## flip coin to generate proposal
  proposal <- current + sample( c(-1, 1), size = 1 )
  ## now make sure he loops around the archipelago
  if (proposal < 1) proposal <- 10
  if (proposal > 10) proposal <- 1
  ## move or not? 
  prob_move <- proposal / current
  current <- ifelse( runif(1) < prob_move, proposal, current )
}
```

把該國王前100週的行程繪製如下：

```{r introBayes12-fig01, cache=TRUE, fig.width=6, fig.height=5,  fig.cap="Results of the king following the Metropolis algorithm. This figure shows the king's current position (vertical axis) across weeks (horizontal axis). In any particular week, it's nearly impossible to say where the king will be.", fig.align='center'}
plot( 1:100, positions[1:100], 
      bty = "n", 
      xlab = "week",
      ylab = "island", 
      col = rangi2)
```


圖 \@ref(fig:introBayes12-fig01) 告訴我們國王的行程幾乎看起來沒有任何規律性。但是事實上，如果你把全部100000個星期的行程總結一下，會神奇地發現國王在每個島嶼所呆的時間恰好都與其人口規模成相應的比例：

```{r introBayes12-fig02, cache=TRUE, fig.width=6, fig.height=5,  fig.cap="Results of the king following the Metropolis algorithm. This figure shows the long-run behavior of the algorithm, as the time spent on each island turns out to be proportional to its population size.", fig.align='center'}
plot(table(positions), 
     bty = "n", 
     xlab = "island", 
     ylab = "number of weeks stayed", 
      col = rangi2)
```

## Metropolis 演算法

上文中國王行程的例子其實是 Metropolis 演算法的一個特例，這就是一個簡單的馬可夫鏈蒙地卡羅過程。我們可以利用這個MCMC過程對模型給出的複雜的事後概率分佈樣本進行採樣。


- 例子中的“島嶼”，其實就是統計模型中的各種參數，它可以不必是離散型的，完全可以是連續型的變量。
- 每個島嶼的“人口規模”，其實是每個參數的事後概率分佈，在參數不同取值時的概率大小。
- 每個島嶼國王實際留駐的時間“週”，其實就是我們通過這個 Metropolis 演算法對事後概率分佈採集的樣本。

## 簡單的 HMC (Hamitonian Monte Carlo) `ulam`

這裏使用非洲大陸地理的數據 `rugged`，來作爲簡單的HMC過程的示範。

```{r introBayes12-02, cache=TRUE}
data("rugged")
d <- rugged
d$log_gdp <- log(d$rgdppc_2000)
dd <- d[ complete.cases(d$rgdppc_2000), ]
dd$log_gdp_std <- dd$log_gdp / mean(dd$log_gdp)
dd$rugged_std <- dd$rugged / max(dd$rugged)
dd$cid <- ifelse( dd$cont_africa == 1, 1, 2)
```

之前，我們使用二次方程近似法 `quap()` 時，加入了交互作用項的模型是：

```{r introBayes12-03, cache=TRUE}
m8.3 <- quap(
  alist(
    log_gdp_std ~ dnorm(mu, sigma),
    mu <- a[cid] + b[cid] * (rugged_std - 0.215) , 
    a[cid] ~ dnorm( 1, 0.1 ), 
    b[cid] ~ dnorm( 0, 0.3 ), 
    sigma ~ dexp( 1 )
  ), data = dd
)
precis( m8.3, depth = 2 )
```


當我們準備使用 HMC 來採樣時，我們需要額外加以準備：

1. 先處理所有需要中心化或者重新更改尺度的變量。
2. 重新製作一個不含有多餘變量的數據集。（推薦）


```{r introBayes12-04, cache=TRUE}
dat_slim <- list(
  log_gdp_std = dd$log_gdp_std, 
  rugged_std = dd$rugged_std,
  cid = as.integer(dd$cid)
)
str(dat_slim)
```



準備好了數據之後，接下來，我們使用 Stan 進行事後分佈樣本採集：

```{r introBayes12-05, cache=TRUE}
m9.1 <- ulam(
  alist(
    log_gdp_std ~ dnorm( mu, sigma ), 
    mu <- a[cid] + b[cid] * ( rugged_std - 0.215 ) , 
    a[cid] ~ dnorm(1, 0.1), 
    b[cid] ~ dnorm(0, 0.3), 
    sigma ~ dexp(1)
  ), data = dat_slim, chains = 1 
)
precis( m9.1, depth = 2 )
```

我們還可以使用多条採樣鏈，及使用多個計算機內核以平行計算提升效率：


```{r introBayes12-06, cache=TRUE}
m9.1 <- ulam(
  alist(
    log_gdp_std ~ dnorm( mu, sigma ), 
    mu <- a[cid] + b[cid] * ( rugged_std - 0.215 ) , 
    a[cid] ~ dnorm(1, 0.1), 
    b[cid] ~ dnorm(0, 0.3), 
    sigma ~ dexp(1)
  ), data = dat_slim, chains = 4, cores = 4
)
show( m9.1 )
precis( m9.1 , depth = 2)
```

除了使用 `traceplot()` 來進行診斷給出軌跡圖之外：


```{r  introBayes12-fig03, cache=TRUE, fig.width=8, fig.height=5,  fig.cap="Trace plot of the Markov chain from the ruggedness model, m9.1. (Gray region is warmup)", fig.align='center'}
traceplot(m9.1)
```

還可以使用 `trunkplot()` 繪製 軌跡排序圖 (trace rank plot)。

```{r introBayes12-fig04, cache=TRUE, fig.width=8, fig.height=5,  fig.cap="Trunk plot of the Markov chain from the ruggedness model, m9.1.", fig.align='center'}
 trankplot( m9.1 )
```

使用 `stancode()` 可以閱讀計算機自動生成的 Stan 代碼：


```{r introBayes12-07, cache=TRUE}
stancode(m9.1)
```


